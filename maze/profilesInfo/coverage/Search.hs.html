<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>module Search where
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>
<span class="lineno">    4 </span>import Maze
<span class="lineno">    5 </span>import DataStructures
<span class="lineno">    6 </span>import Utils
<span class="lineno">    7 </span>import Data.List
<span class="lineno">    8 </span>import Data.Either
<span class="lineno">    9 </span>
<span class="lineno">   10 </span> 
<span class="lineno">   11 </span>euclidDistance :: Square -&gt; Square -&gt; Float
<span class="lineno">   12 </span><span class="decl"><span class="nottickedoff">euclidDistance (x1, y1) (x2, y2) = sqrt (((xf1 - xf2) ^ 2) + ((yf1 - yf2) ^ 2))</span>
<span class="lineno">   13 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">   14 </span><span class="spaces">        </span><span class="nottickedoff">[xf1, xf2, yf1, yf2] = map (fromInteger) [x1, x2, y1, y2]</span></span>
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>manhattanDistance :: Square -&gt; Square -&gt; Integer
<span class="lineno">   17 </span><span class="decl"><span class="istickedoff">manhattanDistance (x1, y1) (x2, y2) = abs (x1 - x2) + abs (y1 - y2)</span></span>
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>adjacent :: Maze -&gt; Square -&gt; [Square]
<span class="lineno">   21 </span><span class="decl"><span class="istickedoff">adjacent m (x, y) = filter (\t -&gt; (not (isWall m t)) &amp;&amp; validSquare m t) cands</span>
<span class="lineno">   22 </span><span class="spaces">    </span><span class="istickedoff">where </span>
<span class="lineno">   23 </span><span class="spaces">        </span><span class="istickedoff">cands = [(x+1, y), (x, y+1), (x-1, y), (x, y-1)]</span></span>
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>expandValidPaths :: Maze -&gt; [Square] -&gt; [[Square]]
<span class="lineno">   26 </span><span class="decl"><span class="nottickedoff">expandValidPaths m [] = [[]]</span>
<span class="lineno">   27 </span><span class="spaces"></span><span class="nottickedoff">expandValidPaths m currPath = xpValids</span>
<span class="lineno">   28 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">   29 </span><span class="spaces">        </span><span class="nottickedoff">lastSquare = last currPath</span>
<span class="lineno">   30 </span><span class="spaces">        </span><span class="nottickedoff">adjSquares = adjacent m lastSquare</span>
<span class="lineno">   31 </span><span class="spaces">        </span><span class="nottickedoff">expanded = map (\new -&gt; currPath ++ [new]) adjSquares    --generamos adyacentes, añadiendo el path al inicio. </span>
<span class="lineno">   32 </span><span class="spaces">        </span><span class="nottickedoff">xpValids = filter (\path -&gt; length path &gt; length currPath) (map unique expanded)</span></span>          
<span class="lineno">   33 </span>                                                                --de los caminos generados, eliminamos duplicados/ciclos 
<span class="lineno">   34 </span>                                                                --y los que no añaden no añaden nodos nuevos los borramos
<span class="lineno">   35 </span>          
<span class="lineno">   36 </span>{-
<span class="lineno">   37 </span>Programar:
<span class="lineno">   38 </span>Búsqueda en anchura         Hecho
<span class="lineno">   39 </span>Búsqueda en profundidad     Hecho
<span class="lineno">   40 </span>IDDFS                       Hecho
<span class="lineno">   41 </span>A*                          Hecho
<span class="lineno">   42 </span>IDA*
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>-}
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>{-
<span class="lineno">   47 </span>FALTARÍA
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>A*
<span class="lineno">   50 </span>Contar heurísticas. Iterar sobre [ [(Square, Integer)] ] (path y distancia desde origen)
<span class="lineno">   51 </span>Al generar (expand, expandValid etc), calcular dist acumulada + heurística, y ordenar la lista según eso
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>IDA*
<span class="lineno">   54 </span>Va a haber que modificar el dfs, pero búsqueda es igual
<span class="lineno">   55 </span>Si dist acumulada + heur &gt; dMax, podar (guardar el mínimo de los que se podan)
<span class="lineno">   56 </span>dMax inicial: heurística de inicio
<span class="lineno">   57 </span>Siguiente iteración: valor mínimo de los que se podaron (guardarlos)
<span class="lineno">   58 </span>Podría estar chulo explorar las ramas del dfs según heurística
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>-}
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>{-
<span class="lineno">   64 </span>walls1 = (genWalls (1,2) (1,8)) ++ (genWalls (1,1) (4,1)) ++ (genWalls (8,1) (9,1)) ++ (genWalls (4,4) (4,8)) ++ (genWalls (6,2) (6,8)) ++ [(7,9), (5,3), (4,0)]
<span class="lineno">   65 </span>    
<span class="lineno">   66 </span>-}
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>          
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>checkSquares :: Maze -&gt; [Square] -&gt; Bool
<span class="lineno">   71 </span><span class="decl"><span class="istickedoff">checkSquares m xs = and (map (validSquare m) xs) &amp;&amp; and (map (\sq -&gt; not (isWall m sq)) xs)</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>dfs :: Maze -&gt; Integer -&gt; Square -&gt; Square -&gt; [Square]
<span class="lineno">   74 </span><span class="decl"><span class="nottickedoff">dfs m dMax ini fin</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="nottickedoff">| not (checkSquares m [ini, fin]) = error &quot;Not valid squares&quot;</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise = dfs_sgle m 0 dMax [] ini fin</span>
<span class="lineno">   77 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">   79 </span><span class="spaces">        </span><span class="nottickedoff">--dfs_sgle genera ramas y recompone el camino.</span>
<span class="lineno">   80 </span><span class="spaces">        </span><span class="nottickedoff">dfs_sgle :: Maze -&gt; Integer -&gt; Integer -&gt; [Square] -&gt; Square -&gt; Square -&gt; [Square]</span>
<span class="lineno">   81 </span><span class="spaces">        </span><span class="nottickedoff">dfs_sgle m dCurr dMax visited ini fin</span>
<span class="lineno">   82 </span><span class="spaces">            </span><span class="nottickedoff">| dCurr &gt; dMax = []                         --profundidad máxima</span>
<span class="lineno">   83 </span><span class="spaces">            </span><span class="nottickedoff">| ini `elem` visited = []                   --ini visitado</span>
<span class="lineno">   84 </span><span class="spaces">            </span><span class="nottickedoff">| ini == fin = [ini]                        --camino encontrado: pasar a llamante</span>
<span class="lineno">   85 </span><span class="spaces">            </span><span class="nottickedoff">| search_subtree_sgle == [] = []            --rama no lleva a solución</span>
<span class="lineno">   86 </span><span class="spaces">            </span><span class="nottickedoff">| otherwise = ini : search_subtree_sgle     --recomponer camino de llamada correcta</span>
<span class="lineno">   87 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">   88 </span><span class="spaces">            </span><span class="nottickedoff">where </span>
<span class="lineno">   89 </span><span class="spaces">                </span><span class="nottickedoff">xs = (adjacent m ini) \\ visited</span>
<span class="lineno">   90 </span><span class="spaces">                </span><span class="nottickedoff">search_subtree_sgle = dfs_multiple m (dCurr + 1) dMax xs (ini : visited) fin</span>
<span class="lineno">   91 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">   92 </span><span class="spaces">        </span><span class="nottickedoff">--dfs_multiple va distinguiendo qué ramas llevan --camino y cuáles no, itera sobre las ramas</span>
<span class="lineno">   93 </span><span class="spaces">        </span><span class="nottickedoff">dfs_multiple :: Maze -&gt; Integer -&gt; Integer -&gt; [Square] -&gt; [Square] -&gt; Square -&gt; [Square]</span>
<span class="lineno">   94 </span><span class="spaces">        </span><span class="nottickedoff">dfs_multiple m _ _ [] _ fin = []                                                    --todas las ramas iteradas</span>
<span class="lineno">   95 </span><span class="spaces">        </span><span class="nottickedoff">dfs_multiple m dCurr dMax (x:xs) visited fin</span>
<span class="lineno">   96 </span><span class="spaces">            </span><span class="nottickedoff">| search_subtree_multiple == [] = dfs_multiple m dCurr dMax xs visited fin      --fue rama incorrecta, iterar por siguiente rama</span>
<span class="lineno">   97 </span><span class="spaces">            </span><span class="nottickedoff">| otherwise = search_subtree_multiple                                           --rama correcta, pasar a llamante para reconstruir camino</span>
<span class="lineno">   98 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">   99 </span><span class="spaces">            </span><span class="nottickedoff">where </span>
<span class="lineno">  100 </span><span class="spaces">                </span><span class="nottickedoff">search_subtree_multiple = dfs_sgle m dCurr dMax visited x fin</span></span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>--bfs_aux hace la iteración completa
<span class="lineno">  106 </span>--Itera sobre una fifo de paths
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>bfs :: Maze -&gt; Square -&gt; Square -&gt; [Square]
<span class="lineno">  109 </span><span class="decl"><span class="nottickedoff">bfs m ini fin</span>
<span class="lineno">  110 </span><span class="spaces">    </span><span class="nottickedoff">| not (checkSquares m [ini, fin]) = error &quot;Not valid squares&quot;</span>
<span class="lineno">  111 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise = bfs_aux m (newFifo [[ini]]) fin</span>
<span class="lineno">  112 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">  113 </span><span class="spaces">        </span><span class="nottickedoff">bfs_aux :: Maze -&gt; Fifo [Square] -&gt; Square -&gt; [Square]</span>
<span class="lineno">  114 </span><span class="spaces">        </span><span class="nottickedoff">bfs_aux m fifo fin</span>
<span class="lineno">  115 </span><span class="spaces">            </span><span class="nottickedoff">| null fifo = []                                            --Fifo vacía: devolver nulo</span>
<span class="lineno">  116 </span><span class="spaces">            </span><span class="nottickedoff">| lastSquare == fin = currPath                          --encontrado: devolver path</span>
<span class="lineno">  117 </span><span class="spaces">            </span><span class="nottickedoff">| otherwise = bfs_aux m nextFifo fin     --no encontrado: expandir inicial y seguir buscando</span>
<span class="lineno">  118 </span><span class="spaces">                </span><span class="nottickedoff">where </span>
<span class="lineno">  119 </span><span class="spaces">                    </span><span class="nottickedoff">Just (currPath, restFifo) = dequeue fifo</span>
<span class="lineno">  120 </span><span class="spaces">                    </span><span class="nottickedoff">lastSquare = last currPath</span>
<span class="lineno">  121 </span><span class="spaces">                    </span><span class="nottickedoff">newPaths = expandValidPaths m currPath</span>
<span class="lineno">  122 </span><span class="spaces">                    </span><span class="nottickedoff">nextFifo = enqueueMult newPaths restFifo</span></span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>--Algoritmo de profundidad iterativa:
<span class="lineno">  126 </span>--Usa un dfs modificado, va aumentando profunidad máxima iterativamente
<span class="lineno">  127 </span>--La modificación consiste en devolver el path y si llegó a hacer alguna poda
<span class="lineno">  128 </span>--Si no lo revisara, cuando no hay camino seguiría aumentando la prof máxima y bucle infinito
<span class="lineno">  129 </span>--Puede haber mejores formas, pero es la que se me ocurre
<span class="lineno">  130 </span>--Si se demuesta que hay camino, se puede usar dfs directamente y no revisar casos
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>iddfs :: Maze -&gt; Square -&gt; Square -&gt; [Square]
<span class="lineno">  134 </span><span class="decl"><span class="nottickedoff">iddfs m ini fin</span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="nottickedoff">| not (checkSquares m [ini, fin]) = error &quot;Not valid squares&quot;</span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise = iddfsIterate m 1 ini fin</span>
<span class="lineno">  137 </span><span class="spaces">        </span><span class="nottickedoff">where</span>
<span class="lineno">  138 </span><span class="spaces">            </span><span class="nottickedoff">iddfsIterate :: Maze -&gt; Integer -&gt; Square -&gt; Square -&gt; [Square]</span>
<span class="lineno">  139 </span><span class="spaces">            </span><span class="nottickedoff">iddfsIterate m n ini fin</span>
<span class="lineno">  140 </span><span class="spaces">                </span><span class="nottickedoff">| (not . null) path = path</span>
<span class="lineno">  141 </span><span class="spaces">                </span><span class="nottickedoff">| (null path) &amp;&amp; pruned = iddfsIterate m (n+1) ini fin</span>
<span class="lineno">  142 </span><span class="spaces">                </span><span class="nottickedoff">| otherwise = []</span>
<span class="lineno">  143 </span><span class="spaces">                    </span><span class="nottickedoff">where</span>
<span class="lineno">  144 </span><span class="spaces">                        </span><span class="nottickedoff">(pruned, path) = dfsSgleCustom m 0 n [] ini fin</span>
<span class="lineno">  145 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  146 </span><span class="spaces">            </span><span class="nottickedoff">dfsSgleCustom :: Maze -&gt; Integer -&gt; Integer -&gt; [Square] -&gt; Square -&gt; Square -&gt; (Bool, [Square])</span>
<span class="lineno">  147 </span><span class="spaces">            </span><span class="nottickedoff">dfsSgleCustom m dCurr dMax visited ini fin</span>
<span class="lineno">  148 </span><span class="spaces">                </span><span class="nottickedoff">| dCurr &gt; dMax = (True, [])                          --profundidad máxima</span>
<span class="lineno">  149 </span><span class="spaces">                </span><span class="nottickedoff">| ini `elem` visited = (False, [])                   --ini visitado</span>
<span class="lineno">  150 </span><span class="spaces">                </span><span class="nottickedoff">| ini == fin = (False, [ini])                        --camino encontrado: pasar a llamante</span>
<span class="lineno">  151 </span><span class="spaces">                </span><span class="nottickedoff">| path == [] = (pruned, path)                        --rama no lleva a solución</span>
<span class="lineno">  152 </span><span class="spaces">                </span><span class="nottickedoff">| otherwise = (pruned, ini : path)                   --recomponer camino de llamada correcta</span>
<span class="lineno">  153 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  154 </span><span class="spaces">                </span><span class="nottickedoff">where </span>
<span class="lineno">  155 </span><span class="spaces">                    </span><span class="nottickedoff">xs = (adjacent m ini) \\ visited</span>
<span class="lineno">  156 </span><span class="spaces">                    </span><span class="nottickedoff">search_subtree_sgle = dfsMultipleCustom m (dCurr + 1) dMax xs (ini : visited) fin</span>
<span class="lineno">  157 </span><span class="spaces">                    </span><span class="nottickedoff">(pruned, path) = search_subtree_sgle</span>
<span class="lineno">  158 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  159 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  160 </span><span class="spaces">            </span><span class="nottickedoff">dfsMultipleCustom :: Maze -&gt; Integer -&gt; Integer -&gt; [Square] -&gt; [Square] -&gt; Square -&gt; (Bool, [Square])                                                       </span>
<span class="lineno">  161 </span><span class="spaces">            </span><span class="nottickedoff">dfsMultipleCustom m dCurr dMax toCheck visited fin</span>
<span class="lineno">  162 </span><span class="spaces">                </span><span class="nottickedoff">| null usefulPaths = (recomposePruneds, [])</span>
<span class="lineno">  163 </span><span class="spaces">                </span><span class="nottickedoff">| otherwise = (recomposePruneds, (head usefulPaths))</span>
<span class="lineno">  164 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  165 </span><span class="spaces">                </span><span class="nottickedoff">where</span>
<span class="lineno">  166 </span><span class="spaces">                    </span><span class="nottickedoff">search = map (\sq -&gt; dfsSgleCustom m dCurr dMax visited sq fin) toCheck   --a cada nodo lo mapeamos a una búsqueda</span>
<span class="lineno">  167 </span><span class="spaces">                    </span><span class="nottickedoff">(pruneds, paths) = unzip search         </span>
<span class="lineno">  168 </span><span class="spaces">                    </span><span class="nottickedoff">usefulPaths = filter (not . null) paths</span>
<span class="lineno">  169 </span><span class="spaces">                    </span><span class="nottickedoff">recomposePruneds = or pruneds</span></span>
<span class="lineno">  170 </span>                    --recuperamos los campos indivs (unzip) y recomponemos solución para pasarla al llamante
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>--Podría ser más sencillo: Devolver Either 
<span class="lineno">  173 </span>--Right [Square] -&gt; Camino 
<span class="lineno">  174 </span>--Left [] -&gt; Alguna poda
<span class="lineno">  175 </span>--Left [] -&gt; Todo recorrido
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>--Otra forma más sencilla: fijar límite máximo de iddfs a máx de cuadrados, en este caso, filas * columnas - walls
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>simpleIddfs :: Maze -&gt; Square -&gt; Square -&gt; [Square]
<span class="lineno">  182 </span><span class="decl"><span class="nottickedoff">simpleIddfs m ini fin</span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="nottickedoff">| not (checkSquares m [ini, fin]) = error &quot;Not valid squares&quot;</span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise = iddfsIterate m 1 max ini fin</span>
<span class="lineno">  185 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">  187 </span><span class="spaces">        </span><span class="nottickedoff">max = numSquares m</span>
<span class="lineno">  188 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="nottickedoff">iddfsIterate :: Maze -&gt; Integer -&gt; Integer -&gt; Square -&gt; Square -&gt; [Square]</span>
<span class="lineno">  190 </span><span class="spaces">        </span><span class="nottickedoff">iddfsIterate m n max ini fin</span>
<span class="lineno">  191 </span><span class="spaces">            </span><span class="nottickedoff">| n &gt; max = []</span>
<span class="lineno">  192 </span><span class="spaces">            </span><span class="nottickedoff">| subsearch == [] = iddfsIterate m (n+1) max ini fin</span>
<span class="lineno">  193 </span><span class="spaces">            </span><span class="nottickedoff">| otherwise = subsearch</span>
<span class="lineno">  194 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  195 </span><span class="spaces">                </span><span class="nottickedoff">where</span>
<span class="lineno">  196 </span><span class="spaces">                    </span><span class="nottickedoff">subsearch = dfs m n ini fin</span></span>
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>
<span class="lineno">  199 </span>data Path = Path [Square] Integer Integer deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord Path</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">  202 </span>    <span class="decl"><span class="istickedoff">compare (Path xs1 real1 pred1) (Path xs2 real2 pred2) = compare pred1 pred2</span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>astar :: Maze -&gt; (Square -&gt; Integer) -&gt; Square -&gt; Square -&gt; [Square]
<span class="lineno">  205 </span><span class="decl"><span class="istickedoff">astar m heuristic ini fin </span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">not (checkSquares m [ini, fin])</span> = <span class="nottickedoff">error &quot;Not valid squares&quot;</span></span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = astarAux m heuristic [Path [ini] 0 <span class="nottickedoff">(heuristic ini)</span>] fin</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">-- En llamante: (manhattanDistance fin )</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  210 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  211 </span><span class="spaces">        </span><span class="istickedoff">astarAux :: Maze -&gt; (Square -&gt; Integer) -&gt; [Path] -&gt; Square -&gt; [Square]</span>
<span class="lineno">  212 </span><span class="spaces">        </span><span class="istickedoff">astarAux _ _ [] _ = <span class="nottickedoff">[]</span></span>
<span class="lineno">  213 </span><span class="spaces">        </span><span class="istickedoff">astarAux m heuristic ((Path route real expected) : rest) fin</span>
<span class="lineno">  214 </span><span class="spaces">            </span><span class="istickedoff">| lastSquare == fin = route                                 --camino encontrado</span>
<span class="lineno">  215 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlyfalse">nextPathSituation == []</span> = <span class="nottickedoff">astarAux m heuristic rest fin</span></span>
<span class="lineno">  216 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = astarAux m heuristic nextPathSituation fin </span>
<span class="lineno">  217 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  218 </span><span class="spaces">            </span><span class="istickedoff">where</span>
<span class="lineno">  219 </span><span class="spaces">                </span><span class="istickedoff">lastSquare = last route</span>
<span class="lineno">  220 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  221 </span><span class="spaces">                </span><span class="istickedoff">adjs = (adjacent m lastSquare)</span>
<span class="lineno">  222 </span><span class="spaces">                </span><span class="istickedoff">sqsExpanded = map (\new -&gt; route ++ [new]) adjs    --generamos path actual + adyacentes</span>
<span class="lineno">  223 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  224 </span><span class="spaces">                </span><span class="istickedoff">adjsValid = filter (\path -&gt; length path &gt; length route) (map unique sqsExpanded) --Solo considerar [Sq] con camino único (no repetidos ni bucles)</span>
<span class="lineno">  225 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  226 </span><span class="spaces">                </span><span class="istickedoff">genPath = map (\sqs -&gt; Path sqs (real + 1) (real + (heuristic (last sqs)))) adjsValid      --Generar con formato Path [Sq] Integer, calculando long esperada</span>
<span class="lineno">  227 </span><span class="spaces">                </span><span class="istickedoff">nextPathSituation = zipSort genPath rest</span></span>
<span class="lineno">  228 </span>
<span class="lineno">  229 </span>--Mejorar: nodos en priority queue
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>idaStar :: Maze -&gt; (Square -&gt; Integer) -&gt; Square -&gt; Square -&gt; [Square]
<span class="lineno">  233 </span><span class="decl"><span class="istickedoff">idaStar m heuristic ini fin </span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">not (checkSquares m [ini, fin])</span> = <span class="nottickedoff">error &quot;Not valid squares&quot;</span></span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = idaStarAux m heuristic (heuristic ini) (numSquares m) ini fin</span>
<span class="lineno">  236 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  237 </span><span class="spaces">        </span><span class="istickedoff">{-idaStarAux devuelve:</span>
<span class="lineno">  238 </span><span class="spaces">        </span><span class="istickedoff">Right [Square] -&gt; Hubo camino (contando vacío)</span>
<span class="lineno">  239 </span><span class="spaces">        </span><span class="istickedoff">Left Integer -&gt; Poda, da mayor camino estimado</span>
<span class="lineno">  240 </span><span class="spaces">        </span><span class="istickedoff">-}</span>
<span class="lineno">  241 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">idaStarAux :: Maze -&gt; (Square -&gt; Integer) -&gt; Integer -&gt; Integer -&gt; Square -&gt; Square -&gt; [Square]</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">idaStarAux m heuristic dCurr ultimateD ini fin </span>
<span class="lineno">  245 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlyfalse">dCurr &gt; ultimateD</span> = <span class="nottickedoff">[]</span>                                                            --Llegado a estimación de prof máx: no hay solución</span>
<span class="lineno">  246 </span><span class="spaces">            </span><span class="istickedoff">| isLeft thisSearch &amp;&amp; pruned = idaStarAux m heuristic dLongest ultimateD ini fin   --Camino no encontrado con podas: seguir profundizando</span>
<span class="lineno">  247 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">isRight thisSearch</span> = fromRight <span class="nottickedoff">[]</span> thisSearch                                      --Camino encontrado, devolver</span>
<span class="lineno">  248 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">[]</span>                                                                    --Camino no encontrado, no hay podas: no hay camino</span>
<span class="lineno">  249 </span><span class="spaces">            </span><span class="istickedoff">where</span>
<span class="lineno">  250 </span><span class="spaces">                </span><span class="istickedoff">thisSearch = dfs_sgle m heuristic 0 dCurr [] ini fin                            --Búsqueda dfs</span>
<span class="lineno">  251 </span><span class="spaces">                </span><span class="istickedoff">(pruned, dLongest) = fromLeft <span class="nottickedoff">(False, 0)</span> thisSearch                             --Recuperar valores</span>
<span class="lineno">  252 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff">dfs_sgle :: </span>
<span class="lineno">  254 </span><span class="spaces">            </span><span class="istickedoff">Maze -&gt; (Square -&gt; Integer) -&gt; Integer -&gt; Integer -&gt; [Square] -&gt; Square -&gt; Square -&gt; Either (Bool, Integer) [Square]</span>
<span class="lineno">  255 </span><span class="spaces">        </span><span class="istickedoff">dfs_sgle m heuristic dCurr dMax visited ini fin</span>
<span class="lineno">  256 </span><span class="spaces">            </span><span class="istickedoff">-- | dCurr &gt; dMax = Left (True, (dCurr + heuristic ini))                           --profundidad máxima: poda</span>
<span class="lineno">  257 </span><span class="spaces">            </span><span class="istickedoff">| thisSqEstimatedPath &gt; dMax = Left (True, thisSqEstimatedPath)                 --ruta estimada mayor que cota: devolver estim. de camino</span>
<span class="lineno">  258 </span><span class="spaces">            </span><span class="istickedoff">| ini == fin = Right [ini]                                                      --camino encontrado: pasar a llamante</span>
<span class="lineno">  259 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlyfalse">ini `elem` visited</span> = <span class="nottickedoff">Left (False, 0)</span>                                          --ini visitado</span>
<span class="lineno">  260 </span><span class="spaces">            </span><span class="istickedoff">| null adj = Left (False, (dCurr + heuristic ini))                              --Camino sin solución (callejón sin salida)</span>
<span class="lineno">  261 </span><span class="spaces">            </span><span class="istickedoff">| isLeft branch = branch                                                        --no se ha encontrado camino, subir cota mín que supere cota</span>
<span class="lineno">  262 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Right (ini : (fromRight <span class="nottickedoff">[]</span> branch))                               --camino encontrado: recomponer camino de llamada correcta</span>
<span class="lineno">  263 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  264 </span><span class="spaces">            </span><span class="istickedoff">where </span>
<span class="lineno">  265 </span><span class="spaces">                </span><span class="istickedoff">thisSqEstimatedPath = dCurr + (heuristic ini)                               --estimación de ruta que pasa por nodo actual</span>
<span class="lineno">  266 </span><span class="spaces">                </span><span class="istickedoff">adj = (adjacent m ini) \\ visited                                           --adyacentes no visitados</span>
<span class="lineno">  267 </span><span class="spaces">                </span><span class="istickedoff">branch = dfs_multiple m heuristic (dCurr + 1) dMax adj (ini : visited) fin  --Búsqueda en hijos</span>
<span class="lineno">  268 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  269 </span><span class="spaces">        </span><span class="istickedoff">dfs_multiple :: </span>
<span class="lineno">  270 </span><span class="spaces">            </span><span class="istickedoff">Maze -&gt; (Square -&gt; Integer) -&gt; Integer -&gt; Integer -&gt; [Square] -&gt; [Square] -&gt; Square -&gt; Either (Bool, Integer) [Square]</span>
<span class="lineno">  271 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  272 </span><span class="spaces">        </span><span class="istickedoff">dfs_multiple m heuristic dCurr _ [] _ fin = Left (False, dCurr)                 --todas las ramas iteradas</span>
<span class="lineno">  273 </span><span class="spaces">        </span><span class="istickedoff">dfs_multiple m heuristic dCurr dMax (x:xs) visited fin                          --iterar sobre las ramas</span>
<span class="lineno">  274 </span><span class="spaces">            </span><span class="istickedoff">| isRight thisBranch = thisBranch                                           --Camino encontrado: subir solución</span>
<span class="lineno">  275 </span><span class="spaces">            </span><span class="istickedoff">| isRight (otherBranches) = otherBranches                                   --Camino encontrado en otro vecino</span>
<span class="lineno">  276 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Left ((pruned1 || pruned2), (max num1 num2))                  --Camino no encontrado: Unificar ramas vecinas</span>
<span class="lineno">  277 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  278 </span><span class="spaces">            </span><span class="istickedoff">where </span>
<span class="lineno">  279 </span><span class="spaces">                </span><span class="istickedoff">thisBranch = dfs_sgle m heuristic dCurr dMax visited x fin              --Profundizar en tu rama</span>
<span class="lineno">  280 </span><span class="spaces">                </span><span class="istickedoff">otherBranches = dfs_multiple m heuristic dCurr dMax xs visited fin      --Recorrer (recursivamente) rama de los vecinos</span>
<span class="lineno">  281 </span><span class="spaces">                </span><span class="istickedoff">(pruned1, num1) = fromLeft <span class="nottickedoff">(False, 0)</span> thisBranch</span>
<span class="lineno">  282 </span><span class="spaces">                </span><span class="istickedoff">(pruned2, num2) = fromLeft <span class="nottickedoff">(False, 0)</span> otherBranches</span></span>
<span class="lineno">  283 </span>                            
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>--Cuidado: si sabemos que hay camino todo es mucho más fácil. No hay que hacer ciertas comprobaciones de si ha habido 
<span class="lineno">  286 </span>--podas y seguir aumentando (siempre habría que seguir aumentando)
<span class="lineno">  287 </span>--Sería buena idea: comprobar que fin tenga adyacentes

</pre>
</body>
</html>
